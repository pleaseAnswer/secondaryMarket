// 深度优先遍历
1. 访问顶点v; visited[v]=1;
2. w=顶点v的第一个邻接点;
3. while(w存在)
    3.1 if(w未被访问) 从顶点v出发递归执行该算法;
    3.2 w=顶点v的下一个邻接点;

// 广度优先遍历
1. 初始化队列Q;
2. 访问顶点v; visited[v]=1; 顶点v入队列Q;
3. while(队列Q非空)
    3.1 v=队列Q的队头元素出队;
    3.2 w=顶点v的第一个邻接点;
    3.3 while(w存在)
        3.3.1 如果w未被访问，则访问顶点w; visited[w]=1; 顶点w入队列Q;
        3.3.2 w=顶点v的下一个邻接点;

// 邻接矩阵[无向图] -- 构造函数
1. 确定图的顶点个数和边数;
2. 输入顶点信息存储在一维数组vertex中;
3. 初始化邻接矩阵; //全为0
4. 依次输入每条边存储在邻接矩阵arc中;
    4.1 输入边依附的两个顶点的编号i,j;
    4.2 将邻接矩阵的第i行第j列的元素置为1;
    4.3 将邻接矩阵的第j行第i列的元素置为1;

// 邻接表[有向图] -- 构造函数
1. 确定图的顶点个数和边数;
2. 输入顶点信息存储在顶点表中，并初始化该顶点的边表;
3. 依次输入边的信息并将边所对应的邻接点信息存储在边表中;
    3.1 输入边依附的两个顶点的编号i,j;
    3.2 生成边表结点s，其邻接点的编号为j;
    3.3 将结点s插入到第i个边表的表头;

// 最小生成树
// Prim算法 -- 邻接矩阵存储
// 基本思想
1. 初始化: U={v0}; TE={};
2. 重复下述操作知道U=V:
    2.1 在E中寻找最短边(u,v),且满足u属于U，v属于V-U;
    2.2 U=U+{v};
    2.3 TE=TE+{u,v};
// 算法
1. 初始化辅助数组shortEdge[n];
2. 输出顶点v0,将顶点0加入到集合U中;
3. 重复下列操作n-1次:
    3.1 在shortEdge[n].lowcost中选取最短边及对应的邻接点编号k;
    3.2 输出顶点k和对应权值;
    3.3 将顶点k加入到集合U中; 
    3.4 调整数组shortEdge[n];

// Kruskal算法
// 基本思想
1. 初始化：U=V; TE={};
2. 重复下述操作直到T中的连通分量个数为1:
    2.1 在E中寻找最短边(u,v);
    2.2 如果顶点u、v位于T的两个不同连通分量，则
        2.2.1 将边(u,v)并入TE;
        2.2.2 将这两个连通分量并为一个;
    2.3 在E中标记边(u,v),使得(u,v)不参加后续最短边的选取;
// 算法
1. 初始化辅助数组parent[n]; num=0;
2. 依次考察每一条边for(i=0;i<arcNum;i++)
    2.1 vex1=edge[i].from所在生成树的根结点
    2.2 vex2=edge[i].to所在生成树的根结点
    2.3 如果vex1!=vex2,执行下述操作:
        2.3.1 parent[vex2]=vex1;
        2.3.2 num++;
        2.3.3 if(num==n-1) 算法结束;

// 最短路径
/**
* Dijkstra算法
* dist[] 元素：点之间的最短路径长度
* path[] 元素：点之间的最短路径的边
* s[]：源点+已生成的终点
*/
1. 初始化数组dist、path和s;
2. while(s中的元素个数<n)
    2.1 在dist[n]中求最小值,其编号为k;
    2.2 输出dist[k]和path[k];
    2.3 修改数组dist和path;
    2.4 将顶点k添加到数组s中;

// 对AOV网进行拓扑排序的基本思想
1. 从AOV网中选择一个没有前驱的顶点并且输出它;
2. 从AOV网中删除该顶点，并且删去所有以它为尾的弧;
3. 重复1 2 直到全部顶点都被输出，或AOV网中不存在没有前驱的顶点;

// 拓扑排序的算法 
1. 栈S初始化;累加器count初始化;
2. 扫描顶点表,将没有前驱(即入度为0)的顶点压栈;
3. 当栈S非空:
    3.1 j=栈顶元素出栈;输出顶点j;count++;
    3.2 对顶点j的每一个邻接点k执行以下操作:
        3.2.1 将顶点k的入度-1;
        3.2.2 如果顶点k的入度为0;则将顶点k入栈;
4. if(count<vertexNum) 输出有回路信息；//vertexNum为顶点数

// AOE网求关键路径
1. 从源点v0出发,令ve[0]=0,按拓扑序列求其余各顶点的最早发生时间ve[i](0<=i<=n-1);
2. 如果得到的拓扑序列中顶点个数小于AOE网中顶点数,则说明网中存在环,不能求关键路径,算法终止;否则执行步骤3;
3. 从终点v[n-1]出发,令vl[n-1]=ve[n-e],按逆拓扑有序求其余各顶点的最迟发生时间vl[i](0<=i<=n-1);
4. 根据各顶点的ve和vl值,求每条有向边的最早开始时间ee[i]和最迟开始时间el[i](0<=i<=e-1);
5. 若某条有向边ai满足条件ee[i]=el[i],则ai为关键活动;